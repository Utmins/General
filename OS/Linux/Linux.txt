=====================================================================
* Storage *
***********

	++++++++++++++
	+ Patritions +
	++++++++++++++

	Системы Linux поддерживают несколько различных типов систем, включая:

		-	FAT
		-	ext2 / ext3 / ext4
		-	XFS
		-	BTRFS
		-	CIFS (Common Internet File System)
		-	VFS (Virtual File System)

	Эти файловые системы могут использоваться в различных ситуациях в зависимости от конкретных потребностей пользователя.

	Также, Linux поддерживает следующие около системыный протоколы:

		-	SMB (Server Message Block)
		-	NFS (Network File System)

	Еще одна вещь, о которой нам нужно поговорить, это то, что известно как индексный узел (Index node), его также сокращенно называют Inode.	
	Индексный узел — это объект, который хранит метаданные о файле или каталоге в заданной файловой системе.
	Эти метаданные могут включать временные значения, например, когда файл был создан и последний раз изменен, они могут иметь информацию о разрешениях и владельце.
	Они могут иметь расположение блоков данных файлов на устройстве хранения и другие фрагменты разнообразной информации.
	В случаях, когда происходит непредвиденное прерывание, файловая система может фактически быстро восстановить себя с помощью журналирования, поскольку она записывает изменения в тех файлах, которые еще не были сделаны в файловой системе внутри этого Inode.

	Первая задача в управлении хранилищем — разбить устройство хранения (partition) на разделы и отформатировать (format) раздел с помощью одной из этих файловых систем.
	Это сделает раздел устройства доступным для чтения и записи данных после его форматирования.

	Когда я использую термин «partition», это просто означает, что это раздел накопителя, который логически действует как отдельный диск.
	Он позволяет преобразовать большой диск в меньшие, более управляемые фрагменты, что приводит к лучшей организации ваших данных.
	Существует три типа разделов, которые вы можете использовать, и каждый из них имеет определенные особенности.

		i)		Primary Partition.
				Основные разделы содержат одну файловую систему или логический диск, и иногда его называют томом.
				Linux любит перемещать некоторые из своих неиспользуемых файлов из ОЗУ в Swap File System (файловая система подкачки), чтобы освободить фактическую физическую память
				Это относится к тому, что мы называем пространством подкачки (swap space).
				Это пространство подкачки — это просто раздел на устройстве хранения, который будет использоваться, когда в системе закончится физическая ОЗУ или физическая память.

		ii)		Extended Partition
				Расширенный раздел также может содержать несколько файловых систем, они называются логическими дисками.
				Этот тип раздела не содержит никаких данных и имеет отдельную таблицу разделов.
				
		iii)		Logical Partition
				Логический раздел — это часть физического диска, которая была разделена и выделена как независимая единица и функционирует как отдельный диск.
			
	++++++++++++++++++
	+ Commands/Tools +
	++++++++++++++++++	

	Также будут моменты, когда вам нужно будет создать новую таблицу разделов или изменить существующие записи в таблице разделов, для этого вы будете использовать утилиту fdisk.
	Это текстовая программа с меню, которая используется для создания, изменения или удаления разделов на данном накопителе.
	Fdisk также позволит вам указать размер этих разделов.

	В дополнение к fdisk, есть еще одна утилита, которую мы можем использовать для управления нашими разделами, она известна как команда GNU Parted.
	Команда GNU Parted будет особенно полезна при создании разделов на новых дисках хранения.
	Этот инструмент можно использовать для создания, уничтожения и изменения размера разделов.
	Команда Parted запускает утилиту GNU Parted, и, как и fdisk, Parted включает в себя интерактивный режим на основе меню, в котором вы можете вводить различные параметры.

	После создания раздела вы не сможете добавить файловую систему в этот раздел, если ядро ​​не сможет прочитать ее из таблицы разделов.
	Поэтому вместо перезагрузки системы лучше выполнить команду partprobe после запуска fdisk или команды GNU Parted.
	Если вы это сделаете, ядро ​​узнает о ваших новых конфигурациях разделов, которые вы только что сделали.
	Команда partprobe будет использоваться для обновления ядра с учетом изменений, которые теперь существуют в данной таблице разделов.
	Сначала команда проверяет таблицу разделов, и если есть какие-либо изменения, она автоматически обновляет ядро ​​с этими изменениями.

	Другая важная команда, которую нужно знать, — это команда mkfs (make file system).
	Команда mkfs используется для создания файловой системы Linux на устройстве, которое обычно является разделом диска.

	+++++++++++++++++++++
	+ FS Imortant Files +
	+++++++++++++++++++++

	Еще одна вещь, которую нам нужно рассмотреть, это файл fstab.
	Файл fstab — это файл конфигурации, в котором хранится информация об устройствах хранения и разделах, а также о том, где и как эти разделы должны быть смонтированы.
	Файл fstab будет расположен в каталоге /etc.
	Он будет прочитан системой во время процесса загрузки, и его может редактировать только ваш пользователь root.
	
	Файл fstab состоит из нескольких строк, по одной для каждой файловой системы, о которой знает система.
	Каждая строка имеет шесть полей, которые будут разделены пробелами или табуляциями:

		1)	Device or Partition Name
			Оно указывает имя устройства или файловой системы, которые вы хотите смонтировать.
		
		2)	Default Mount Point
			Точка монтирования по умолчанию указывает, где будет смонтирована файловая система, поэтому это может быть, слэш (/) для корневой файловой системы в качестве примера.

		3)	File System Type
			Указывает тип файловой системы, используемой этим устройством или разделом.

		4)	Mount Options
			Указывает набор разделенных запятыми параметров, которые будут активированы при монтировании файловой системы.

		5)	Dump Options
			Указывает, должна ли утилита Dump создавать резервную копию файловой системы.

		6)	fsck Options
			Указывает порядок, в котором утилита fsck или утилита File System Checker должны проверять файловую систему.

	Другой файл, о котором нам нужно поговорить, находится в каталоге /etc и известен как C-R-Y-P-T-T-A-B, или crypttab.
	Он расположен по адресу /etc/crypttab и выполняет функцию, похожую на файл fstab, но его цель — хранить информацию о зашифрованных устройствах и разделах, которые должны быть разблокированы и смонтированы при загрузке системы.
	Его формат будет похож на формат файла fstab, но он включает необязательное поле пароля для разблокировки зашифрованных устройств.

	++++++++++++++++++++
	+ Partinion Naming +
	++++++++++++++++++++

	В Linux все будет рассматриваться как файл, даже каталог или целый том или раздел диска.
	Когда вы посмотрите на файловую систему, вы увидите, что она записана как каталог, известный как /dev, для устройства.
	Каталог /dev — это специальный файл, который содержит сведения обо всех файлах и подкаталогах, которые размещены в нем.
	
	Linux использует соглашения об именах, чтобы устройства хранения легко находили система, когда они подключены и когда система загружается.
	Для устройств хранения соглашение об именах обычно выражается тремя частями, давайте рассмотрим пример.

	Если у меня есть устройство с именем /dev/sda1, это на самом деле многое мне говорит об этом устройстве следующее

		-	sd
			Это первая часть, которая относится к определенному типу контроллера, который использует это устройство.

		-	a
			Это вторая часть, которая будет относиться к первому целому диску, потому что "a" — это первая буква алфавита.
			Поэтому, если бы у нас был второй диск, это было бы b, если бы у нас был третий диск, это было бы c, и так далее.

		-	1
			Это третья часть этого — это цифра один,
			Цифра относится к порядковому номеру раздела на этом диске.
			Если бы у нас было два раздела или три раздела, у нас здесь было бы два или три.

	Таким образом, когда у меня есть что-то вроде /dev/sda1, мы знаем, что у нас есть первое устройство хранения и первый раздел на этом устройстве хранения, потому что это sda1.

	Помимо использования этого соглашения об именовании, Linux также имеет несколько различных схем постоянного именования, которые помогают нам идентифицировать устройства.
	
		i)		Controller-based naming
				Именование на основе контроллера иногда может быть проблематичным в системах с несколькими типами одного и того же контроллера.
				Поэтому вместо этого мы можем использовать схему постоянного именования (persistent naming scheme), чтобы преодолеть это и сделать его более предсказуемым.

		ii)		Persistent naming scheme (based on Device's hardware serial number)
				Если я использую схему постоянного именования, основанную на серийном номере оборудования устройства (device's hardware serial number), я собираюсь сделать это, используя номер /dev/disk/ID.

		iii)		Persistent naming scheme (based on identifier)
				Если я использую схему постоянного именования, которая ссылается на идентификатор, основанный на кратчайшем физическом пути к устройству, я могу использовать что-то вроде /dev/disk/path.
				
		iv)		Persistent naming scheme (based on universally unique identifier)
				Наконец, если я собираюсь использовать схему постоянного именования, основанную на универсальном уникальном идентификаторе или UUID, я бы записал это как /dev/disk/UUID.
				И это будет ссылаться на тот универсальный уникальный идентификатор, который назначается устройству, когда на нем впервые создается файловая система.

	+++++++++++++++++++++++++++++++++++++++++++
	+ Special Character Devices (directories) +
	+++++++++++++++++++++++++++++++++++++++++++

	Как я уже упоминал ранее, в Linux все создается как файл и монтируется в файловой системе, поэтому существуют специальные символьные устройства, которые устанавливаются по умолчанию в большинстве дистрибутивов Linux.
	И каждое из них используется для определенной цели.

		-	/dev/null
			Это особый тип виртуального устройства, который позволяет вам отбрасывать все, что вы отправляете на него или перенаправляете в него.
			Представьте себе /dev/null как большую черную дыру, и любые потоки данных или потоки символов, с которыми вы не хотите иметь дело или сохранять в файл, вы можете просто перенаправить их в /dev/null, и оно исчезнет навсегда. 
			сли вы попытаетесь прочитать данные с устройства /dev/null, вы просто получите сообщение о конце файла, потому что вы фактически достигли конца этого файла, поскольку этот файл всегда пуст и ничего не содержит.

		-	/dev/zero
			Оно используется как особый тип виртуального устройства, которое будет возвращать нулевой символ каждый раз, когда вы будете читать с него.
			Если вы перенаправите вывод на устройство /dev/zero, оно отбросит данные так же, как это делало устройство /dev/null.
			Но большая разница в том, что когда вы попытаетесь прочитать данные с /dev/zero, оно будет действовать иначе, чем /dev/null.
			Вы не получите этот конец файла обратно немедленно.
			Вместо этого он отправит вам обратно нулевой символ ASCII шестнадцатеричного значения 0x00.

			Возникает резонный вопрос - Зачем вам использовать /dev/zero, если все, что он делает, это отправляет вам бесконечный поток нулей всякий раз, когда вы читаете с него?
			Что ж, это на самом деле полезно, когда вы пытаетесь очистить жесткий диск, переопределив его кучей нулей.
			Чтобы сделать это, вы можете просто использовать команду dd, которая означает disk duplicator.
			Вы вводите, dd if=/dev/zero of=dev/sda1 bs=1GB count=1024.
			И эта команда перезапишет жесткий диск объемом в один терабайт, смонтированный как sda1, серией нулей по всему диску для всего размера в один терабайт, используя размеры блоков по одному гигабайту каждый.

		-	/dev/urandom
			Это особый тип виртуального устройства, которое будет возвращать рандомизированную серию псевдослучайных чисел.
			Например, если вы создаете программу или скрипт в системе Linux и хотите сгенерировать случайные числа для чего-то вроде определения того, какая сторона брошенной игральной кости будет возвращена вашей программой, вы можете использовать /dev/urandom, чтобы сделать это.
			Например, предположим, что вы хотите получить пять случайных символов.
			Вы можете ввести, head -c5 /dev/urandom, а затем нажать Enter.
			Это вернет пять случайных символов из этого устройства специального символа, называемого /dev/urandom.

	++++++++
	+ RAID +
	++++++++

	Как мы уже обсуждали, мы использовали физические устройства хранения, но сопоставление устройств (device mapping) превращает эти физические устройства хранения в виртуальные устройства хранения.
	В Linux средство сопоставления устройств (device mapper) создает виртуальное устройство и передает данные с этого виртуального устройства на одно или несколько физических устройств.

	DM-multipath — это функция ядра Linux, которая обеспечивает избыточность и повышенную производительность для блочных устройств хранения.
	Если один путь выходит из строя, DM-multipath переключится на один из оставшихся путей, сохраняя это устройство хранения доступным для чтения и записи.
	Пакет инструментов multipath позволяет вам управлять DM-multipath для устройств хранения, и обычно вы найдете файл конфигурации, расположенный в /etc/multipath.conf

	Команда mdadm — это инструмент, который будет использоваться для управления программными RAID-массивами.
	Этот тип конфигурации программного RAID является альтернативой использованию device mapper и DM-multipath.
	Инструмент mdadm позволяет создавать, управлять и контролировать RAID-массивы.

	Вы можете задаться вопросом	-	как мне получить информацию о моем RAID из моей системы Linux и ее ядра?
	Что ж, для этого вам понадобиться файл /proc/mdstat.
	Это файл содержит снимок состояния RAID или MD ядра.
	Чтобы прочитать этот файл в вашей системе, просто введите cat /proc/mdstat в интерфейсе командной строки и нажмите ENTER.
	Это отобразит на вашем экране информацию о любых известных конфигурациях RAID в вашей системе.
	В разделе «personalities» файл сообщит мне, какие RAID-массивы могут поддерживаться моим ядром.

	++++++++++++++++++
	+ Logical Volume +
	++++++++++++++++++

	Далее мы обсудим одно из основных приложений картографа устройств, которое называется менеджером логических томов (logical volume manager) или LVM.
	LVM будет отображать целые физические устройства и разделы в один или несколько виртуальных контейнеров, известных как группы томов.
	Внутри этих групп томов находятся один или несколько логических томов.
	В конечном счете, эти логические тома становятся устройствами хранения, с которыми будут взаимодействовать и работать система, пользователь и приложения.

	С помощью менеджера логических томов вы можете динамически создавать, удалять и изменять размер томов без необходимости перезагрузки системы.
	Вы также можете отображать несколько логических томов на нескольких физических устройствах и можете создавать виртуальные снимки каждого логического тома, чтобы можно было быстро и легко вернуть том в определенное состояние.
	
	В Linux device mapper создает виртуальные устройства и передает данные с этого виртуального устройства на одно или несколько физических устройств.
	Каталог /dev/mapper содержит все логические тома в данной системе, которые управляются менеджером логических томов.
	Устройства в этом каталоге обычно называются /dev/mapper/<volume_group_name>-<logical_volume_name>
	Менеджер логических томов делит свои инструменты управления томами на три категории на основе трех различных компонентов, включая

		-	physical volume tools (инструменты физических томов
		-	volume group tools (инструменты групп томов)
		-	logical volume tools (инструменты логических томов)

	Для работы с logical volume в Linux используются 3 взаимозаменяемые группы коммнад, где каждая имеет свои уникальные фишки

		-	pv...
		-	vg...
		-	lv...

	++++++++++++++++++++++++
	+ Mounting File System +
	++++++++++++++++++++++++

	После форматирования разделов и логических томов с файловыми системами нам нужно сделать их доступными для пользователей.
	Поэтому мы собираемся сделать эти файловые системы доступными для пользователей, смонтировав их в операционной системе.
	
	Прежде чем операционная система сможет читать с диска или записывать на него, файловая система на одном из этих разделов диска должна быть смонтирована.
	Поскольку файловая система на самом деле представляет собой просто большой массив байтов, обычно хранящихся в разделе, вам нужно получить доступ к файловой системе, смонтировав ее.

	Mount Point	-	это точка доступа, где информация будет храниться на локальном или удаленном устройстве хранения.
	Эта точка монтирования обычно будет пустым каталогом, в который будет загружена или смонтирована файловая система, чтобы сделать эту файловую систему доступной для пользователей.
	Правильный способ использования команды mount — ввести mount [options] {device_name} {mount_point}.

	Вы также можете размонтировать файловую систему.
	И это означает, что она будет отсоединена от каталога путем выгрузки или размонтирования, так что она больше не будет использоваться.
	Для этого мы собираемся использовать команду umount.
	Чтобы размонтировать файловую систему, она не должна использоваться в данный момент.
	Это означает, что вы не можете иметь какие-либо файлы из этой файловой системы, открытые в каком-либо приложении, например, в программе обработки текста или электронной таблице или чем-то подобном.
	Правильный способ использования команды umount — ввести umount [options] {mount_point}.

	Помните, что монтирование файловой системы обычно происходит во время процесса запуска, и оно управляется файлом конфигурации /etc/fstab.
	Простой способ запомнить это	-	fstab означает  file system table.
	И это список всех файловых систем, которые необходимо смонтировать, их назначенные точки монтирования и любые другие параметры, которые могут потребоваться для определенных файловых систем.

	Другой метод монтирования файловой системы — использование systemd или system daemon.
	Systemd.mount можно использовать для создания нового монтируемого модуля для монтирования этой файловой системы.
	Чтобы настроить это, вам нужно создать текстовый файл, расположенный в каталоге /etc/systemd/system, и назвать его <something>.mount
	
	Например, здесь я собираюсь создать текстовый файл с именем /etc/systemd/system/var-lib-docker.mount.
	И он будет использоваться для монтирования определенного диска и его UUID в каталог /var/lib/docker в качестве точки монтирования.
	В примере была использована файловая система btrfs и параметров по умолчанию.
	Чтобы включить это, я собираюсь использовать systemctl и ввести systemctl enable var-lib-docker.mount в командной строке.
	Когда я перезагружу свою систему, будет создана эта новая точка монтирования, и диск будет смонтирован в нее.

	Последнее, на что хотелось бы обратить внимнаие относительно файловых систем, — это концепция FUSE, которая является файловой системой в пользовательском пространстве (Filesystem in USErspace)
	FUSE — это программный интерфейс в системах Linux, который позволяет непривилегированным пользователям создавать свои собственные файловые системы без редактирования базового кода ядра.
	Она изначально разрабатывалась и проектировалась как виртуальная файловая система, которая позволяет вам указывать, как можно выполнять запросы на чтение, запись и статистику в файловой системе, а также как монтировать эту новую файловую систему, которую вы создаете.
	FUSE обычно используется для создания виртуальных файловых систем, которые отсоединены от базового физического носителя или самих дисков.
	И это позволяет им действовать как своего рода транслятор между различными типами файловых систем по мере необходимости.

	Например, если вам нужно иметь возможность читать или записывать на том на основе NTFS, но ваша система не поддерживает это изначально, вы можете написать программу трансляции, используя файловую систему в пользовательском пространстве, чтобы предоставить вам эту возможность.

	Другие распространенные применения FUSE — это возможность локальной операционной системы Linux взаимодействовать с облачными системами хранения файлов, такими как Amazon S3 Buckets или Microsoft Azure Blobs.
	Как вы можете догадаться, FUSE действительно полезен для чтения и записи во всевозможные файловые системы, которые вы затем можете легко монтировать внутри вашей операционной системы Linux.

	++++++++++++++++++++++++
	+ Managing File System +
	++++++++++++++++++++++++

	Для управления нашими файловыми системами мы будем использовать множество различных файлов и конфигураций.
	
		-	/etc/mtab
			Этот файл очень похож на файл /proc/mounts в том, как он сообщает о состоянии текущих смонтированных файловых систем.

		-	/proc/mounts
			Данный файл обычно более точен и включает в себя более актуальную информацию о файловых системах, чем файл /etc/mtab.

		-	/proc/partitions
			Этот файл является частью виртуальной файловой системы, которая содержит информацию о каждом разделе, который в данный момент подключен к системе.
			Формат файла /proc/partition содержит столбцы, включая такие вещи,

				major
				Основной столбец представляет класс устройства, так что его можно сопоставить с соответствующим драйвером.

				minor
				Дополнительный столбец разделяет разделы на физические устройства

				number of blocks
				Cтолбец количества блоков относится к количеству физических блоков, которые занимает раздел

				name
				Cтолбец имени относится к имени раздела.

	Команды, которые мы можем рассмотреть, это:

		-	lsbk
			Это команда, которая будет использоваться для отображения всей информации о блочных устройствах хранения, которые в данный момент доступны в данной системе.
			Вывод будет отображаться в древовидном формате, где каждый физический диск будет наверху дерева, а каждый раздел или логический том будет ответвляться от этого устройства.
			Отображаемая здесь информация будет включать names, major and minor numbers, the size, the device type, and the mount point.
			Правильный способ использования этой команды — ввести lsblk [options] {device_name}
			В этой команде есть много параметров, которые вы можете выбрать в зависимости от своих потребностей.

		-	blkid
			Он предлагает схожую с lsblk функциональность, но просто выводит каждое блочное устройство в плоском формате и включает некоторую дополнительную информацию, такую ​​как UUID устройства в разделе и тип файловой системы.
			ВВод данной команды аналогичен lsbk	-	blkid [options] {device_name}

	Теперь, когда дело доходит до управления файловыми системами и разделами, некоторые инструменты предназначены только для работы с определенными типами файловых систем, такими как FAT или EXT или NTFS или XFS или что-то в этом роде.
	Некоторые из них могут работать с несколькими типами или со всеми типами, но некоторые определенные инструменты работают лучше для определенных файловых систем.
	
	К примеру, если вы собираетесь работать с файловой системой EXT, которая является файловой системой по умолчанию в Linux, есть несколько инструментов, которые вы можете использовать по сути в любом поколении типа файловой системы EXT, будь то ext2, three или four.
	Некоторые из наиболее распространенных и полезных инструментов для управления файловыми системами EXT включают:

		-	e2fsck

		-	resize2fs
			Если Вам понадобится изменить размер существующего раздела, когда ваш раздел заполнится и вам понадобится больше места.
			В этом случае вы можете использовать что-то вроде resize2fs.
			Эта утилита позволит вам увеличить или уменьшить размер файловой системы.
			Команда resize2fs позволяет вам изменить размер файловых систем ext2, ext3 или ext4.
			Ее можно использовать для увеличения или уменьшения несмонтированной файловой системы, расположенной на устройстве.
			Если файловая система смонтирована, ее можно использовать для расширения размера смонтированной файловой системы, предполагая, что ядро ​​поддерживает изменение размера в режиме онлайн.
			Однако размер файловой системы никогда не может быть больше размера раздела.
			Если периметр размера не указан, он будет по умолчанию равен размеру раздела и заполнит все оставшееся пространство.
			Если вы хотите использовать эту команду, просто введите	-	resize2fs [options] {device/file_system_name} <desired_size>

		-	tune2fs
			Эта команда позволяет вам настраивать различные настраиваемые параметры для файловых систем ext2 и ext3.
			Настраиваемые параметры позволяют вам удалять резервные блоки, изменять количество резервных блоков, указывать количество монтирований между проверками, указывать временные интервалы между проверками и многое другое.
			Естественно, это также помогает вам подтверждать существующие параметры, настроенные для ваших файловых систем.
			Вы также можете использовать tune2fs для добавления журнала в существующую файловую систему ext2 или ext3.
			Если файловая система уже смонтирована, журнал будет виден в корневом каталоге этой файловой системы.
			Если файловая система не смонтирована, журнал будет скрыт.
			Чтобы запустить команду tune2fs, вам нужно ввести	-	tune2fs [options] {device/file_system_name}

		-	dumpe2fs
			Данная комнада позволяет вам выгружать данные ext2, ext3 или ext4.
			Он фактически распечатает суперблок и информацию о группе блоков для вашего выбранного устройства.
			Это может быть полезно при устранении неполадок в неисправной файловой системе.
			Чтобы использовать его, просто введите dumpe2fs, параметры и имя устройства или файловой системы.

		-	fsck
			В любой момент может произойти ошибка файловой системы из-за сбоя питания, отказа оборудования или неправильного выключения вашей системы.
			Если это произойдет, вы будете использовать команду fsck.
			Обычно эта команда fsck используется для проверки правильности и действительности файловой системы.
			Большинство систем автоматически запускают команду fsck во время загрузки, так что любые ошибки, если они будут обнаружены, могут быть обнаружены и исправлены до использования системы.
	
			Более того, файловая система должна быть размонтирована, прежде чем ее можно будет просканировать с помощью fsck, чтобы предотвратить повреждение файловой системы.
			Иногда для монтирования или изменения файловой системы потребуется ее восстановление.
			Даже если проверка не сообщает о каких-либо повреждениях файловой системы, она все равно может считать ее поврежденной изнутри и требовать восстановления.
			Чтобы запустить fsck, вы будете вводить	-	fsck [options] {device/file_system_name}

			Суперблок файловой системы — это то, что содержит метаданные о файловой системе, включая ее размер, тип и статус.
			Суперблок имеет решающее значение для функционирования файловой системы.
			Если он будет поврежден, вы не сможете монтировать и работать с этой файловой системой.
			Поэтому вам нужно использовать инструмент вроде fsck, чтобы восстановить суперблок, если он будет поврежден

	В случае работы с типами файловой системы XFS используется комнада - xkf_<option>.
	Использование той или иной опции предоставит соответсвующую инфомрацию
	К примеру	-	xfs_info используется для отображения сведений о файловой системе XFS, включая информацию о ее блоках..

	Другая команда, о которой вам следует знать, — это команда lsscsi, также известная как команда LS SCSI.
	Эта команда используется для вывода информации об устройствах SCSI, подключенных к системе Linux.
	Наиболее распространенным типом устройств SCSI, используемых в системах Linux в наши дни, являются накопители и внешние жесткие диски, поэтому я и привожу ее здесь.
	Если вы просто введете lsscsi в интерфейсе командной строки и нажмете Enter, она может ответить одной строкой для каждого устройства SCSI, подключенного к вашей системе.
	Например, она может сообщить вам, что жесткий диск SCSI подключен к 0080, и он смонтирован в /dev/SDA, и этот диск произведен компанией Fujitsu

	Однако большинство из нас на самом деле не будет использовать много устройств SCSI, потому что они уже довольно старые и устарели.
	Вместо этого вы можете столкнуться с устройствами, подключенными по оптоволоконному каналу.
	Для взаимодействия с этими устройствами и отображения их статистики вы можете использовать команду fcstat.
	Введя fcstat в интерфейсе командной строки, вы сможете отобразить общую статистику об устройствах Fibre Channel, подключенных к вашей системе
	Это обычно представляет собой высокоскоростные и большие по емкости внешние сетевые массивы хранения данных.

	+++++++++++++++++++++++
	+ Directory Structure +
	+++++++++++++++++++++++

	Файловая система Linux состит из обычных файлы, которые включают в себя:

		-	text files
		-	executable files/programs
		-	input for programs
		-	output from programs.

	Помимо всего этого, файловая система Linux также состоит из других типов файлов:

		-	directories
			Каталоги ссылаются на контейнер для других файлов.

		-	special files
			Специальные файлы включают системные файлы, которые хранятся в каталоге /dev.

		-	links
			Ссылки делают файл доступным в нескольких частях файлового дерева системы.

		-	domain sockets
			Доменные сокеты обеспечивают межпроцессное сетевое взаимодействие, защищенное средствами управления доступом файловой системы

		-	named pipes
			Каналы имен позволят процессам взаимодействовать друг с другом без использования сетевых сокетов

	Если вы хотите просмотреть все это и определить тип просматриваемого файла, вы можете ввести в терминале	-	 file [options] <file_name>.

	Стандарт иерархии файловой системы (FHS)	-	это совместный документ, который определяет набор рекомендаций по именам файлов и каталогов и их расположению в данной системе Linux.
	Согласно определению FHS, самым верхним каталогом в файловой системе Linux всегда будет корневой каталог.
	Это обозначается одной косой чертой (/).
	Ниже корневого каталога находятся различные подкаталоги, которые стандартизированы как часть FHS.
	Внутри файловой системы Linux есть много каталогов, поэтому мы рассмотрим здесь только некоторые из них:

		-	/bin 
			Этот каталог хранит основные утилиты командной строки и двоичные файлы.

		-	/boot
			Этот каталог хранит все файлы, необходимые для загрузки операционной системы Linux.

		-	/dev
			Этот каталог хранит драйверы аппаратных и программных устройств.
			Он также сожержит информацию о наличии имющихся файловой систем(-ы), которая будет представлять устройства, подключенные к системе, например, ваш жесткий диск или принтер.
			Если, к примеру, вы посмотрите на ваш жесткий диск, то /dev/sda1, и это будет указывать на первый раздел на первом жестком диске.

		-	/etc
			Этот каталог будет хранить основные файлы конфигурации
			Например, у вас может быть файл /etc/samba/smb/conf, который хранит данные конфигурации Samba и позволяет вам использовать SMB в сети.

		-	/home
			Этот каталог хранит домашние каталоги ваших пользователей, включая все их личные файлы.
			Он содержит личные файлы пользователя или файлы, которые в противном случае являются специфичными для конкретного пользователя.
			Домашний каталог — это то место, куда вы попадаете, когда изначально входите в систему.
			В Linux по умолчанию каждому пользователю, кроме пользователя root, назначается подкаталог в /home.
			Так что если бы мое имя пользователя было Jason, я бы был /home/jason.
			Пользователь может создавать подкаталоги и файлы в своем каталоге, таким образом могут быть созданы поьзовательсике каталоги типа /home/jason/movies или /home/jason/downloads, /home/jason/documents.

		-	/lib
			Этот каталог хранит общие библиотеки программ, которые требуются ядру, утилитам командной строки и другим двоичным файлам.

		-	/media
			Этот каталог хранит точки монтирования для сменных носителей, таких как CD-ROM, DVD или даже старые дискеты.

		-	/mnt
			Это каталог относится к точке монтирования для временных монтируемых файловых систем
			Например, если подключить USB-накопитель в свою систему, то можно  увидеть его в каталоге /mnt.

		-	/opt
			Этот каталог хранит дополнительные файлы для больших пакетов программного обеспечения (это наш дополнительный каталог).
			Эти пакеты обычно создают подкаталог со своим именем в каталоге /opt, а затем помещают свои файлы в этот подкаталог.
			Например, если установить сканер уязвимостей Nessus, то можно увидеть один подкаталог с именем /opt/nessus, который будет содержать все файлы для этой программы сканирования.

		-	/proc
			Этот каталог является каталогом процесса.
			Он относится к виртуальной файловой системе, которая представляет пользователю постоянно обновляемую информацию ядра в типичном формате файла.
			Также, каталог /proc предоставляет значительную информацию о запущенных процессах ядра.
			В каталоге /proc есть различные файлы, к примеру:

				/proc/cmdline (или /cmdline)
				Это файл, который содержит параметры, передаваемые ядру загрузчиком при загрузке системы.
				Сюда входят такие вещи, как монтирование ядра только для чтения и тому подобное.

				/proc/cpuinfo
				Это файл, который содержит информацию о процессоре, такую ​​как его архитектура, имя, тактовая частота, размер кэша и многое другое.

				/proc/devices
				Это файл, который содержит список всех драйверов символьных и блочных устройств, загруженных в текущее работающее ядро.

				/proc/filesystems
				В данному каталоге будет файл, содержащий список всех типов файловых систем, поддерживаемых этим ядром, а также какие из них в данный момент смонтированы.

				/proc/meminfo
				Это файл, который содержит информацию об использовании вами оперативной памяти, включая общий объем памяти, свободную память и многое другое.

				/proc/modules
				Он содержит информацию о модулях, которые в данный момент установлены в системе.

				/proc/stat
				Он содержит различную статистику о системе с момента последней перезагрузки.
				В зависимости от версии используемого вами ядра, вы можете повлиять на функциональность вашей системы.
				Поэтому важно иметь файл для проверки используемой вами версии.

				/proc/version
				Эот файл укажет несколько точек информации о ядре Linux, включая версию ядра Linux, которая в данный момент запущена, версию GNU Compiler Collection или GCC, которая используется для компиляции этого ядра, имя пользователя компилятора ядра и время последней компиляции ядра.		

				/proc/mounts
				Данный файл будет содержать информацию обо всей смонтированной системе.

		-	/root
			Этот каталог будет ссылаться на домашний каталог пользователя root.
			Данный каталог находится за пределами каталога /home.

		-	/sbin
			Этот каталог хранит двоичные файлы, которые используются для завершения процесса загрузки, и другие, которые будут использоваться пользователем root
			Например, /sbin/ifconfig — это файл для двоичного файла команды ifconfig, которая используется для управления сетевыми интерфейсами в данной системе.

		-	/sys
			Это Ваш системный каталог, этакая виртуальная файловая система, которая хранит информацию об устройствах, например, /sys/block включает ссылки на устройства, которые хранятся в различных подкаталогах в каталогах /sys/devices/location. И это представляет собой иерархию устройств внутри нашего ядра.

		-	/temp
			Этот каталог хранит временные файлы, которые будут потеряны при завершении работы системы.

		-	/usr
			Это Ваш общепользовательский каталог.
			В основном он используется для чтения и зранения небольших программы и файлы, доступных всем пользователям.
			Также этот каталог имеет несколько важных подкаталогов:

				/usr/bin	-	содержит исполняемые программы, которые могут быть выполнены всеми пользователями.
				/usr/local	-	содержит пользовательские приложения, которые хранятся здесь по умолчанию.
				/usr/lib	-	содержит библиотеки объектов и внутренние двоичные файлы, необходимые для исполняемых программ.
				/usr/lib64	-	имеет то же назначение, что и /usr/lib, за исключением того, что он предназначен для 64-разрядных систем, а не для старых 32-разрядных систем.
				/usr/share	-	будет включать независимые от архитектуры файлы только для чтения, которые могут совместно использоваться различными архитектурами операционной системы, например, используем ли мы систему на базе X86 или систему на базе X64 или систему на базе ARM.
							
		-	/var
			Этот каталог в котором хранятся переменные файлы или файлы, которые, как ожидается, будут постоянно меняться по мере работы системы.
			Сюда входят такие вещи, как файлы журналов, спулы принтеров и некоторые файлы конфигурации сетевых служб.

 
=====================================================================
* KERNEL *
**********

Ядро (kernel) ​​является основой операционной системы Linux и выполняет различные важнейшие функции, такие как:

	-	System Initialization
	-	File System Access
	-	Process Scheduling
	-	Memory and Hardware Management
	-	Resource Allocation of a System

Ядро также управляет всеми аппаратными устройствами, которые подключены к данной системе.
А также содержит команды системного уровня и другие функции, которые обычно скрыты от пользователей.

Ядро имеют тенденцию делить программное обеспечение, работающее в памяти, на два пространства, а именно:

	i)	kernel space
		Пространство ядра — это просто место, где ядро ​​выполняет службы, которые оно предоставляет.

	ii)	user space
		Пространство пользователя — это область памяти, которая включает в себя все, что находится за пределами пространства ядра.
		Это может включать в себя все от высокоуровневых приложений, с которыми пользователи взаимодействуют напрямую, до процессов, работающих в фоновом режиме, и различных низкоуровневых системных библиотек.

Разделение между этими двумя областями памяти полезно, поскольку оно обеспечивает большую стабильность и безопасность для нашей системы.
Программное обеспечение в одном пространстве не обязательно может мешать программному обеспечению в другом пространстве.

Также ядра можно классифицировать как

	-	monolithic (монолитные)
		В монолитном ядре все системные модули, такие как драйверы устройств или файловые системы, работают внутри пространства ядра.
		В результате монолитное ядро ​​может быстро взаимодействовать со всеми различными устройствами
		Однако его главным недостатком является его размер, который, как правило, приводит к более высокому потреблению оперативной памяти.
		Кроме того, сбой драйвера устройства может фактически привести к нестабильности системы, если вы используете монолитное ядро.
		Поэтому вместо этого многие люди предпочитают использовать архитектуру микроядра.

	-	microkernels (микроядра)
		Когда вы используете архитектуру микроядра, само ядро ​​запускает минимальное количество ресурсов, необходимых для фактической реализации полностью функциональной операционной системы.
		По сравнению с монолитным ядром, микроядра имеют меньшие пространства ядра и вместо этого имеют гораздо большие пользовательские пространства.
		Это означает, что микроядра меньше, хотя в тоже самое время имеют увеличенный размер, но они фактически потребляют гораздо меньше памяти.
		Кроме того, они фактически считаются гораздо более стабильными и безопасными.
		Однако микроядра также имеют тенденцию предлагать худшую производительность, чем монолитное ядро, потому что есть гораздо больше переключений вещей в память или из нее.

Когда мы говорим о ядре Linux, важно помнить, что это свободное и открытое монолитное ядро ​​в целом, и оно управляет всеми ресурсами операционной системы.
У монолитного ядро, драйверы устройств работают в пространстве ядра и имеют полный доступ к оборудованию.
Архитектура ядра Linux предоставляет множество полезных функций, включая управление виртуальной памятью, поддержку сетей TCP/IP, общие библиотеки и многое другое.

Другим важным качеством ядра Linux является его модульность.
Это позволяет пользователям настраивать и расширять функциональность ядра в соответствии со своими конкретными потребностями.
В ядро ​​Linux включено множество изменений и новых функций.
Версии ядра Linux (к примеру - 2.6.39) имеют следующий формат номера ядра был w.x.y.z., где:

	«W»	-	это основная версия, например, версия 2.
	«X»	-	это основная версия ревизии, например, 2.6.
	«Y»	-	это номер младшей версии, 2.6.39,
	«Z»	-	это номер патча.
Однако после версии 2.6.39 они фактически решили сократить формат номера версии.
Поэтому следующей версией была версия 3.0 после 3.19, вместо того чтобы перейти к 3.20, они перешли к 4.0, и это было сделано для удобства чтения, а не из-за каких-либо реальных крупных технических достижений, которые мы имели с основными версиями.
Более новые версии ядра продолжат эту тенденцию избегать больших младших чисел с несколькими десятичными знаками, такими как 2.6.39.2, и вместо этого использовать что-то вроде 3.20 или 4.0.

Поскольку ядро ​​выполняет различные функции для контроля и управления операциями системы, оно будет состоять из нескольких слоев, работающих в пространстве ядра.
Мы называем это слоем ядра SCI (System Call Interface):

	-	system calls layer
		Этот уровень обрабатывать системные вызовы, отправляемые пользовательскими приложениями, которым необходимо обратиться к ядру.
		Это позволяет приложениям пользовательского пространства запрашивать службы из пространства ядра, такие как время обработки и выделение памяти

	-	process management layer
		Он позволяет ядру планировать и обрабатывать системные вызовы и управлять несколькими системными вызовами одновременно.
		Для орабатывая различных процессов, выделяется отдельное пространство выполнения на процессоре и гарантирует, что выполнение одного процесса не будет мешать другим процессам.

	-	memory management layer
		Данный уровень ядра будет управлять памятью компьютера, что является одной из самых сложных задач, выполняемых ядром.
		Так же, как и совместное использование процессора, память системы также должна быть разделена между различными ресурсами пользовательского пространства.

	-	file system management layer
		Уровень ядра управления файловой системой будет управлять файловой системой.
		Это включает в себя хранение, организацию и отслеживание файлов и данных на данном компьютере.

	-	abstraction layer
		Ядро также поддерживает виртуальную файловую систему или VFS, которая обеспечивает этот уровень абстракции базовых данных, которые организуются в сложных структурах.
		Так что это выглядит как единая структура.

	-	device management layer
		Уровень ядра управления устройствами будет управлять устройствами, контролируя доступ к устройствам и взаимодействуя между пользовательскими приложениями и аппаратными устройствами на компьютере.
		Когда приложение пользовательского пространства отправляет системный вызов, ядро ​​будет считывать запрос, а затем передавать его драйверам, которые управляют действиями этого конкретного устройства.

Как можно заметить, ядро ​​действительно находится в центре всего, и именно там мы собираемся выполнять всю основную обработку устройств для наших систем.

	++++++++++++++++++
	+ Kernel Modules +
	++++++++++++++++++

	Как мы уже знаем	-	ядро Linux загружается в память загрузчиком.
	Модули ядра динамически загружаются и выгружаются по требованию, и они предоставляют драйверам устройств возможность разрешать ядру получать доступ к новому оборудованию, поддерживать различные типы файловых систем и в целом расширять функциональность ядра без необходимости перезагрузки системы
	И это может привести к большой гибкости во время операций.

	Каталог /usr/lib/modules содержит модули различных версий ядра, которые будут установлены в системе.
	Он содержит каталог, названный по номеру версии ядра.
	Внутри этого каталога модули хранятся в различных подкаталогах в зависимости от категорий, к которым они принадлежат.

	Например, драйвер Bluetooth может храниться в /usr/lib/{modules}/<version_number>/kernel/drivers/bluetooth.
	Внутри каталога /usr/lib/{modules}/<version_number>/kernel будет несколько подкаталогов для каждого из различных устройств:

		/arch		-	для различных архитектур внутри этих модулей
		/crypto		-	содержит модули для шифрования и других криптографических функций
		/drivers	-	содержит модули для различных типов оборудования
		/fs		-	содержит модули для различных типов файловых систем
		/net		-	является каталогом, содержащим модули для сетевых компонентов,

	Если мы хотим использовать установку, мы можем выполнить команду install <module_name> [command] для запуска указанной команды без вставки модуля в ядро.

	Помимо загрузки модулей в ядро ​​во время выполнения вы также можете изменить некоторые параметры ядра во время его работы.
	Вы можете использовать эти параметры для повышения производительности системы, усиления безопасности, настройки сетевых ограничений, изменения параметров виртуальной памяти и многого другого.
	Для этого вам нужно перейти в каталог /proc/sys.
	В этом каталоге перечислены все параметры, которые вы можете настроить в своей системе.
	
	Как и каталоги, содержащие модули ядра, этот каталог /proc/sys разделен на несколько категорий, включая:

		-	crypto
			который включает параметры, связанные с шифрованием и другими криптографическими службами
	
		-	debug
			который включает параметры, связанные с отладкой ядра

		-	dev
			который включает параметры, связанные с определенными аппаратными устройствами
	
		-	fs
			который включает параметры, связанные с данными файловой системы
			
		-	kernel
			который включает параметры, связанные с различными функциями ядра
			
		-	net
			который включает параметры, связанные с сетевыми функциями

		-	user, который включает параметры, связанные с ограничениями пространства пользователя

		-	vm
			который включает параметры, связанные с управлением виртуальной памятью.

	Другая действительно мощная команда в Linux — это команда sysctl.
	Это мощная команда, которая действует как интерфейс для динамического изменения параметров ядра.
	С помощью этой команды вы можете изменять параметры ядра без перекомпиляции ядра или перезагрузки компьютера.
	Все доступные для изменения параметры можно найти в каталоге /proc/sys.
	Вы также можете просмотреть значение параметра, отобразив содержимое соответствующего файла.
	У него есть различные параметры.

	Файл /etc/sysctl.conf позволит изменять конфигурацию вашего работающего ядра Linux.
	Эти изменения могут включать в себя всевозможные улучшения вашей сети, конфигурации безопасности или ведения журнала информации.
	Поэтому, как вы видите, очень важно понимать эти модули и то, как их изменять, потому что они привносят много возможностей в вашу систему Linux.

	Если вы хотите просмотреть любые сообщения, которые были отправлены в буфер сообщений ядра во время или после загрузки системы, то используете команду dmesg (display message или driver message)
	Драйверы устройств постоянно отправляют сообщения ядру, указывая состояние модулей и параметров, с которыми взаимодействуют драйверы.
	Эти драйверы также могут отправлять диагностические сообщения ядру в случае возникновения каких-либо ошибок.
	Вы можете использовать команду dmesg для поиска потенциальных проблем с компонентами ядра или для проверки того, что определенные модули действительно загружены.

=====================================================================
* Linux BOOT Process *
**********************

Booting — это процесс запуска или перезапуска компьютера и загрузки операционной системы для доступа пользователя.
В процессе загрузки среда загрузки считывает небольшую программу, которая хранится в постоянной памяти, известной как RAM.
Затем эта программа выполняет различные операции внутри вашей ROM или оперативной памяти, и это загрузит операционную систему и сделает ее доступной для использования.

Linux, как и большинство других операционных систем, необходимо загрузить, прежде чем она сможет функционировать.
Существуют различные параметры, связанные с процессом загрузки, которые вы также сможете настроить, если вам это нужно.

Boot Loader (загрузчик)	-	это небольшая программа, которая хранится в RAM и которая будет загружать ядро ​​с устройства хранения, например жесткого диска, а затем она будет запускать операционную систему.
Когда компьютер включается или перезагружается, базовая система ввода-вывода выполняет начальные тесты, а затем передает управление главной загрузочной записи, и именно там будет находиться загрузчик.

Загрузчик также может использовать три основных компонента, которые будут работать вместе для систематической загрузки операционной системы на трех различных этапах:

	1)	Это программа загрузочного сектора, и он загружается загрузочной средой при запуске
		Его основная функция — загрузить второй загрузчик.

	2)	Загрузчик второго этапа будет загружать операционную систему, и он содержит загрузчик ядра.
		С другой стороны, установщик загрузчика будет контролировать установку секторов диска и может быть запущен только при загрузке с диска.
		Он будет координировать действия загрузочного сектора и загрузчика.

		Существует несколько вариантов загрузки, в которых вы можете загрузить Linux

			BIOS (Basic Input/Output System)
			UEFI (Unified Extensible Firmware Interface)
			ISO (Optical Dist, Thumb Drive)
			PXE (Preboot eXecution Environment, e.i. Network Share)
			NFS (Network File Server)

Бывают моменты, когда что-то идет не так, и именно поэтому у нас есть механизм, позволяющий системе определять, произошла ли фатальная ошибка, и она будет реагировать на это, выполняя то, что называется Kernel Panic.
Фатальная ошибка обычно приводит к тому, что система становится нестабильной или полностью непригодной для использования.
Существует программное обеспечение, которое обрабатывает эти паники ядра, и оно отображает сообщение об ошибке пользователю и сбрасывает текущее состояние памяти ядра на устройство хранения для последующей отладки.
В зависимости от того, как настроена ваша система, обработчик паники либо автоматически перезагрузит систему, либо выключится и будет ждать, пока пользователь снова включит систему.

=====================================================================
* System Components *
*********************

	++++++++++++++++
	+ Localization +
	++++++++++++++++

	В мире операционных систем локализация считается процессом адаптации компонентов системы для использования в рамках определенной культуры, отличной от той, для которой изначально была разработана система.
	В практическом смысле, это обычно означает

		-	перевод компонентов интерфейса на определенные языки
		-	преобразование единиц измерения в систему, используемую в определенном регионе
		-	настройка раскладки клавиатуры на ту, которая больше подходит для того, с чем пользователь знаком
		-	установка атрибутов даты и времени в определенном месте.

	Локализация системы Linux важна для организаций, предоставляющих услуги Linux персоналу и клиентам по всему миру.
	Работа с местным временем и совместимой клавиатурой улучшает пользовательский опыт для наших международных пользователей.


	Использование правильного часового пояса действительно важно для многих задач и процессов, связанных с системой.
	Например:

		-	Модуль cron будет использовать часовой пояс системы для выполнения запланированных заданий, которые вы собираетесь выполнять в фоновом режиме или в определенное время дня.
		-	Часовой пояс также будет использоваться для ваших журналов, включая временные метки в этих журналах.
		-	Каталог /usr/share/zoneinfo является контейнером для всех региональных часовых поясов, которые вы можете настроить для использования системой.
		Подкаталоги в этом контейнере также организуют языки по регионам.

	Обычно вы устанавливаете часовой пояс во время установки операционной системы, но вы также можете легко изменить его в любое время позже.
	Тем не менее, существует и другой способ изменить часовой пояс системы — создать символическую ссылку на один из этих отдельных файлов часовых поясов в файле /etc/localtime.
	Однако в некоторых дистрибутивах на основе Debian, Вы можете найти его в /etc/timezone.
	Этот текстовый файл перечислит часовой пояс по структуре регионов, которую вы увидите в каталоге /usr/share/zoneinfo.

	Команда date будет использоваться для печати даты в указанном формате.

	Другая команда, о которой мы хотим поговорить, это time date control, которая записывается как timedatectl.
	Она будет использоваться для установки системной даты и времени и может принимать одну из нескольких подкоманд.
	Команда timedatectl выведет на экран три разных часа, которые использует система, и вы сможете получить информацию о них:

		i)		Local clock будут отражать текущее время в локали системы.

		ii)		Universal clock будут отображать время независимо от вашего местного часового пояса.
				Они будут использовать международное стандартное координированное всемирное время, известное как UTC
				И это то же самое, что и время по Гринвичу или время по Гринвичу.
	
		iii)		С другой стороны, hardware clock функционируют на аппаратном уровне и будут показывать время даже при выключенном компьютере из-за батареи на материнской плате.
				Когда вы используете команду управления временем и датой, можно установить аппаратные часы на ваше местное время.
				Однако это не рекомендуется, поскольку RTC не обновляется автоматически.
				Они будут обновляться только внешними средствами, такими как другие установленные операционные системы. 

	Несколько операционных систем могут настраивать RTC на летнее время, известное как DST.
	И это может фактически привести к чрезмерной коррекции.

	Команда аппаратных часов или hwclock позволит вам просматривать и устанавливать аппаратные часы.
	Как упоминалось ранее, настоятельно рекомендуется поддерживать аппаратные часы в соответствии с UTC, чтобы предотвратить чрезмерную коррекцию другими операционными системами.
	Вы также можете использовать команду аппаратных часов для корректировки систематического дрейфа (systematic drift).

	Теперь систематический дрейф — это предсказуемое количество времени, на которое аппаратные часы отстают или спешат каждый день, что делает их неточными и нарушает их согласованность с системными часами.
	/etc/adjtime — это файл, в котором записывается информация о том, когда и насколько изменяются аппаратные часы.

	Команда управления локалью или команда localectl будет использоваться для просмотра и настройки системных локалей и настроек раскладки клавиатуры.
	Системные локали будут определять, как они будут представлять различные культурные элементы, в частности, язык, используемый в интерфейсе.
	Как и команда timedatectl, команда localectl будет иметь различные подкоманды для управления системными локалями и раскладкой клавиатуры.

	++++++++++++
	+ Services +
	++++++++++++

	Службы — это программы или процессы, которые постоянно работают на ваших серверах, обычно с момента загрузки сервера и до его выключения.
	Эти службы используются для обеспечения постоянной поддержки запросов и мониторинга от других процессов или внешних клиентов.
	Некоторые примеры известных служб — Apache для запуска веб-сервера и Postfix для запуска почтового сервера.
	Однако, как и любые другие компоненты Linux, службы также могут управляться.

	В настоящее время большинство служб реализовано в виде "демонов" (deamon), которые запускают программы, работающие в фоновом режиме без необходимости вмешательства человека.
	Это означает, что демоны будут находиться в состоянии покоя до тех пор, пока событие не заставит их выполнить какую-либо функцию или действие.
	Вот несколько примеров часто используемых "демонов"

		-	initd
			Демон init ссылается на файл конфигурации и инициирует процессы, перечисленные в этом файле.
			Это подготавливает вашу систему к запуску необходимого вам программного обеспечения.
			Он будет работать непрерывно до тех пор, пока система не будет выключена.
			И программы в вашей системе не смогут работать без демона init.

			Каталог /etc/init.d будет хранить все ваши скрипты инициализации для всех ваших служб.
			Эти скрипты управляют инициализацией служб на определенном уровне выполнения.
			Скрипты будут вызываться из файла /etc/inittab, когда начнется инициализация системы, используя различные символические ссылки, которые находятся в этом файле.

		-	systemd
			В Linux вы можете инициализировать систему через SysVinit и systemd.
			Метод, который будет активен в вашей системе Linux, повлияет на то, как вы будете управлять службами в этой системе.
			Например, если вы используете программный пакет systemd, он предоставит метод init для инициализации системы.
			Он также предоставит инструменты для управления службами в этой системе, которые являются производными от демона init.
			
			Пакет systemd был разработан как замена другим методам, таким как SysVinit, и теперь является доминирующим методом init, который используется в современных дистрибутивах Linux.
			Он также предложит несколько улучшений по сравнению со старыми методами:
				)	он поддерживает параллелизацию, например одновременный запуск программ для более быстрой загрузки и снижения накладных расходов оболочки.
				)	В systemd контрольные группы также используются для отслеживания процессов вместо идентификаторов процессов или PID, что обеспечивает лучшую изоляцию и категоризацию для всех ваших процессов.
			systemd использует файлы юнитов, чтобы определить, как он будет обрабатывать юниты, представляющие собой системные ресурсы, которыми systemd фактически может управлять.

			В systemd цели — это метод группировки файлов конфигурации юнитов вместе, как правило, для представления определенных режимов работы.
			Каждый файл цели dot будет использоваться для определения одного из нескольких способов, которыми может работать система, например, запуск только в среде командной строки, запуск в графической среде рабочего стола, инициирование завершения работы системы и многие другие.
			Таким образом, вы можете активировать цель, чтобы загрузить желаемую среду, если захотите.

	Ресурсы могут включать сетевые службы, блочные устройства хранения данных, периферийные устройства, файловые системы и многое другое.
	Демоны будут получать доступ ко всем этим различным ресурсам и управлять ими для вас, а файлы единиц также могут использоваться для установки переменных и параметров системной среды, а также того, какие значения будут передаваться из родительского процесса в дочерний процесс, который он создает.

	Команда, о которой стоит упомянуть, — это systemctl, или system control.
	Команда system control позволяет вам управлять демоном инициализации systemd, и вы можете просматривать запущенные службы, включать и отключать службы для запуска при загрузке или в текущем сеансе, а также определять статус этих служб и управлять системной целью.
	В большинстве случаев команда systemctl будет использоваться для управления службами, но есть некоторые дополнительные команды systemd, которые вы также можете использовать.
	Например, hostnamectl позволит вам просматривать сетевое имя хоста системы и другую информацию об оборудовании системы и ядре Linux, которое она запускает.
	Вы также можете использовать команду для изменения имени хоста системы.

	Команда telinit позволит вам переключиться на текущий уровень выполнения системы. 
	В средах systemd команда telinit будет автоматически преобразована в соответствующий целевой запрос.
	
	Команда runlevel выведет предыдущий и текущий уровни выполнения системы, каждый из которых будет разделен пробелом.

	Еще одна команда, о которой нужно рассказать, — это команда проверки конфигурации (chkconfig).
	Команда проверки конфигурации может использоваться для управления службами на каждом уровне выполнения.
	Она также используется для запуска или остановки служб во время запуска системы.

	+++++++++++++
	+ Processes +
	+++++++++++++

	Процессы проходят жизненный цикл от создания до своего окончательного завершения.
	Cуществует пять различных состояний, в которых может находиться процесс в течение этого жизненного цикла.
	Каждое из них определяет, как система или другие приложения могут взаимодействовать с данным процессом
	Знание состояния процесса может помочь вам определить, что делать с этим процессом, или может помочь вам диагностировать проблемы, связанные с этим процессом:

		1)	Running State
			Состояние выполнения означает, что процесс в данный момент выполняется в пространстве пользователя или пространстве ядра.

		2)	Interruptible Sleep State
			Состояние прерываемого сна означает, что процесс отказывается от доступа к ЦП и ожидает повторной активации планировщиком.
	
		3)	Uninterruptible Sleep State
			Состояние не прерываемого сна означает, что процесс проснется только тогда, когда его ресурсы, которых он ждет, станут ему доступны.
			В противном случае он останется в состоянии сна.

		4)	Zombie State
			Состояние зомби означает, что процесс был завершен, но он еще не был освобожден своим родительским процессом, поэтому он не может принять сигнал kill.

		5)	Stopped State
			Состояние остановки указывает на то, что процесс был остановлен отладчиком или с помощью сигнала kill.

	У каждого процесса в вашей системе есть уникальный идентификатор процесса, известный как PID, и он получает его, когда запускается системой
	Таким образом пользователи и система могут идентифицировать этот процесс.
	PID — это неотрицательное целое число, которое увеличивается для каждого нового процесса, который запускается в системе.
	К примеру, у демона init всегда есть PID, равный единице, потому что это первый процесс, который запускается в системе, и он становится родительским для всех других процессов в этой системе.
	После того, как этот процесс будет запущен, тогда процессы смогут запускаться системой или пользователем этим демоном init, и им будет назначен более высокий доступный номер, потому что они будут чем-то большим, чем единица, потому что они запускаются демоном init.

	Когда вы устраняете какие-либо неполадки, вам нужно знать, каков PID процесса или этот идентификационный номер, потому что это помогает вам понять, как завершить его, изменить его приоритет или выполнить другие задачи управления для этого данного процесса.

	Eсли вы хотите это найти, вы можете использовать команду pgrep.
	Команда pgrep просматривает текущие запущенные процессы и выводит в стандартный вывод идентификаторы процессов, соответствующие критериям выбора.
	Если вы используете pgrep, вы сможете идентифицировать процесс на основе нескольких различных факторов, даже если вы не знаете его точный PID.
	Это поможет вам определить PID, а определение PID обычно является вашим первым шагом в управлении процессом.
	
	Другой способ найти идею процесса запущенной программы — использовать команду pidof.
	Она позволит вам найти идентификатор процесса названной программы, который вы ей дадите.

	Другая команда, которую вы можете использовать, известна как ps.
	Команда ps вызывает таблицу процессов, которая представляет собой запись, обобщающую текущие запущенные процессы в данной системе.
	Когда команда запускается без каких-либо параметров, она отобразит все процессы, запущенные текущей оболочкой, с подробностями.
	Сюда входят такие вещи, как:

		-	PID
		-	terminal associated with that process
		-	accumulated CPU time
		-	command that started that exact process.
	Однако вместе с этой командой можно использовать различные параметры, чтобы отфильтровать отображаемые поля или процессы.

	Как и ps, команда top выведет список всех процессов, запущенных в системе Linux.
	Она действует как инструмент управления процессами, позволяя вам расставлять приоритеты, сортировать или завершать процессы в интерактивном режиме.
	Она отобразит динамическое состояние процесса и отразит изменения в реальном времени.
	Различные нажатия клавиш в этом инструменте также выполнят различные действия по управлению процессами.

	В дополнение к top есть более новая версия под названием htop
	htop также является интерактивным, системным монитором, просмотрщиком процессов и менеджером процессов, но он действительно делает гораздо больше и гораздо проще в использовании, чем top.
	Это потому, что htop был разработан еще в 2004 году, тогда как top был разработан еще в 1984 году.
	Теперь один недостаток заключается в том, что htop не устанавливается по умолчанию во всех дистрибутивах Linux.
	Поэтому, если вы хотите использовать htop, и он еще не установлен в вашем дистрибутиве, вам придется установить его с помощью менеджера пакетов или скомпилировать его из исходного кода и установить на вашем сервере Linux.
	Теперь, когда дело доходит до некоторых больших различий между top и htop, все сводится к тому, как он представляет данные.
	Когда вы используете top, это очень простой черно-белый интерфейс, и он только текстовый.
	Но когда вы начнете использовать htop, вы получите более красочный интерфейс с некоторой текстовой графикой, которая будет отображать именно то, что происходит.
	Например, в верхней части экрана на дисплее htop вы увидите графическое представление ЦП, памяти и пространства подкачки, а также сколько используется и сколько свободно.
	Затем он продолжит показывать вам все различные процессы, пользователей, которые запускают эти процессы, и всю информацию, которую вы захотите узнать об этих процессах в вашей системе,
	Он делает это в цветовой кодировке, поэтому становится действительно легко быстро выбрать информацию, которую вы ищете, когда вы используете htop вместо top.

	Другая команда, о которой мы хотим поговорить, — systemd-analyze.
	Теперь команда systemd-analyze используется для получения статистики производительности для операций загрузки.
	Команда принимает одну или несколько подкоманд, которые определяют, какой тип информации будет напечатан и как она будет напечатана.

	Список открытых файлов (The list of open files) или команда lsof выведет список всех файлов, которые в данный момент открыты для всех ваших активных процессов в системе.
	Это может включать в себя все, от текстового файла до файла устройства.
	По сути, любой объект в этой системе может быть проанализирован как файл.
	Иногда вам будет запрещено изменять файл, если он уже открыт другим процессом.
	Поэтому вы можете использовать команду lsof для определения процесса-нарушителя, который вам нужно завершить, чтобы вы могли взять этот файл под контроль.
	Вы также можете использовать команду lsof для анализа того, как процесс использует файлы, что может быть действительно полезно, если вы идентифицируете вредоносные процессы или процессы, которые имеют нежелательные побочные эффекты в данной системе.
	Команда lsof или список открытых файлов выведет каждый файл, который открыт процессом, на отдельной строке на экране.
	Он выведет такую ​​информацию, как:

		-	name of the command or process
		-	PID
		-	invoking user
		-	file descriptor
		-	what kind of permissions the file has been opened with
		-	the type of file and the name of the file

	Еще одна вещь, которую операционная система делает для нас, — это планирование процессов (schedules out those processes), чтобы дать каждому из них некоторое процессорное время.
	Это известно как планировщик.
	Планировщик обычно действительно эффективен при назначении процессорного времени, но не каждое решение, которое он принимает, будет считаться оптимальным.
	В некоторых случаях вам может потребоваться вручную указать вашему процессору, чтобы он отдавал приоритет определенным процессам над другими.
	
	Процессы будут приоритетными на основе заданного числа, которое с ним связано, где-то от -20 до 19.
	Это значение известно как значение nice или значение niceness.
	Если у вас меньшее число, это означает, что у вас более высокий приоритет.
	Например, если у вас есть процесс со значением nice -18, он получит больше процессорного времени, чем процесс со значением nice 15, потому что -18 намного меньше 15.
	Процесс также унаследует значение nice от своего родителя.
	И по умолчанию значение, которое он всегда будет получать, равно нулю.

	Команда nice позволит вам запустить команду со значениями nice, отличными от значений по умолчанию, которые она будет получать.

	Команда nice обычно используется для запуска нового процесса с заданным приоритетом, но есть и другая команда, если вы хотите изменить существующий процесс и его значение nice, она известна как renice.
	renice — это команда, позволяющая вам изменить приоритет планирования уже запущенного процесса.

	nohup или no hangup — это команда, которая не даст процессу завершиться, когда пользователь выходит из системы.
	Например, предположим, что администратор запустил скрипт резервного копирования, а затем вышел из системы.
	По умолчанию этот скрипт фактически прекратил бы работу. Это было бы плохо, поскольку это означало бы, что наше резервное копирование прекратит работу.
	Но если мы используем nohup перед обычной командой, например, nohup.backup script, этот скрипт продолжит работу даже после выхода администратора из системы.

=====================================================================
* Linux Server Roles *
**********************

При использовании Linux существует широкий спектр сетевых служб, которые можно настроить и запустить как часть предоставляемых вами служб.
Поскольку существует так много типов серверов, которыми на самом деле может быть сервер, Linux просто устанавливает основные по умолчанию.
Таким образом, у вас будет достаточно места для любых дополнительных пакетов или файлов, которые вам может понадобиться добавить позже.

Однако во время процесса установки, если вы выберете общую роль сервера, Linux фактически установит различные пакеты, которые вам понадобятся для этой роли сервера.
Вы даже можете выбрать один или несколько наборов этих различных серверов или ролей сервера, и все это программное обеспечение будет установлено для вас.
Например, у меня может быть один сервер Linux, который будет служить файловым сервером Samba, а также DNS-сервером и SSH-сервером.
Если выбрать все три эти роли, Linux установит все три этих набора пакетов и зависимостей, чтобы можно было запустить эти функции.

После того, как вы разбили и установили базовую операционную систему, вы можете перейти в свою операционную систему Linux и выбрать из предопределенной коллекции различных типов программного обеспечения.
Сюда входят:

	-	Network Time servers (NTP)
	-	Secure Shell servers (SSH)
	-	Web servers
	-	PKI and Certificate servers
	-	Domain name resolution servers (DNS)
	-	DHCP servers
	-	Simple Network Management Protocol servers (SMTP)
	-	Centralized Authentication or LDAP servers
	-	Proxy servers
	-	and many others.

	+++++++++++++++++++
	+ NTP Server Role +
	+++++++++++++++++++

	NTP означает сетевой протокол времени (Network Time Protocol).
	И по умолчанию это служба или сервер, который НЕ будет работать на машине Linux.
	Поэтому, Вам нужно включить это, если вы хотите иметь возможность управлять им.

	NTP дает вам возможность синхронизировать время по всей сети, используя один сервер в качестве источника времени для всего остального в сети.
	Если вы хотите, чтобы ваш сервер Linux был этим окончательным источником времени, вам нужно запустить NTP Damon, который установит сервер NTP на вашей машине Linux.
	В дополнение к протоколу NTP, вам нужно программное обеспечение для использования NTP.
	И один из самых распространенных, используемых в Linux, известен как	-	Crony.

	Crony был разработан для работы в широком диапазоне условий, включая прерывистое сетевое подключение, сильно перегруженные сети, меняющиеся температуры, из-за которых обычные компьютерные часы могут терять время, и возможность работы на виртуальной машине.
	Так что если вам нужна действительно универсальная реализация NTP, вы всегда можете использовать Crony и Crony Damon, чтобы иметь возможность сделать это.

	+++++++++++++++++++
	+ SSH Server Role +
	+++++++++++++++++++

	SSH означает Secure Shell Service.
	Secure Shell предоставит вам аутентифицированный зашифрованный метод подключения к удаленной или локальной системе по сети.
	Чаще всего вы увидите, что SSH используется как протокол удаленного администрирования, но его также можно использовать для туннелирования других различных типов трафика через него безопасным способом.
	Например, если вы хотите запустить FTP, по умолчанию трафик не зашифрован.
	Так что если вы входите на FTP-сервер, это имя пользователя и пароль могут видеть другие люди в сети, но если вы на самом деле туннелируете FTP-трафик через SSH-соединение, он станет зашифрованным, потому что SSH зашифрован по умолчанию.

	Windows, пол умолчанию, не поставляется с SSH-клиентом.
	Так что даже если вы настроите SSH-сервер на своей машине Linux, машина Windows не будет знать, как к нему подключиться.
	Если вы используете Windows в качестве повседневной операционной системы и пытаетесь подключиться к серверу Linux через SSH, вам придется установить сторонний инструмент, такой как PuTTY.
	И это позволит вам работать из системы Windows и подключаться по SSH к серверу SSH, работающему в среде Linux.
	И таким образом вы сможете подключиться к удаленному серверу через Интернет и выполнить свои настройки.

	+++++++++++++++++++
	+ Web Server Role +
	+++++++++++++++++++

	Веб-серверы могут быть как незащищенными, так и защищенными.
	Если они незащищены, вы будете использовать HTTP, который является протоколом передачи гипертекста.
	И он работает с использованием TCP через порт 80.

	Если вы используете защищенную и зашифрованную версию, это известно как HTTPS, что означает Hyper Text Transfer Protocol Secure.
	Он использует TCP через порт 443 для установления соединения.
	
	Как правило, для запуска одной из этих служб HTTP или HTTPS — это просто используемый протокол, но сервер, который вы собираетесь использовать, будет чем-то другим.
	Обычно это что-то вроде Apache или Nginx.
	Когда у вас работает этот сервер, он размещает все веб-сайты в Интернете.
	И поэтому, если вы хотите запустить свой собственный веб-сервер на машине Linux, вам нужно установить сервер Damon, известный как Apache или Nginx, или один из других, которые есть, чтобы иметь возможность работать через порт 80 или порт 443 и доставлять эти веб-страницы, файлы и изображения через Интернет вашим пользователям.

	+++++++++++++++++++++++++++++++
	+ PKI and certificate servers +
	+++++++++++++++++++++++++++++++

	Сертификаты используются для предоставления способа гарантирования чьей-либо личности, будь то пользователь или сам сервер.
	Эти сертификаты известны как цифровые сертификаты, и они являются частью системы PKI или инфраструктуры открытых ключей.
	И она использует асимметричное шифрование и методы хеширования для проверки того, что кто-то является тем, за кого себя выдает.
	
	Однако для этого вам нужен центральный сервер для управления всеми этими сертификатами.
	И он известен как CA или центр сертификации (Certificate Authority).
	Эти CA или центры сертификации используются для управления регистрацией, утверждением, истечением срока действия и отзывом всех этих различных цифровых сертификатов.
	Если вы работаете в крупной организации, вполне возможно, что вы используете свой собственный центр сертификации, чтобы иметь возможность создавать цифровые сертификаты для всех ваших пользователей и всех ваших машин внутри вашей сети.
	
	Как правило, если вы собираетесь размещать веб-сервер, у вас также установлен цифровой сертификат, но он не из вашего собственного центра сертификации.
	Он получен от стороннего доверенного центра сертификации, например Verisign или Entrust, и таким образом другие люди за пределами вашей организации, когда они подключаются к вашему веб-серверу, также могут доверять этому серверу, поскольку этот сервер назначен этой доверенной третьей стороной.

	+++++++++++++++++++++++++++
	+ Domain Name Server Role +
	+++++++++++++++++++++++++++

	DNS-сервер выполняет для нас разрешение имен.
	Разрешение имен означает, что мы можем использовать эти легко запоминающиеся имена хостов, такие как diontraining.com, и автоматически преобразовывать их в IP-адрес для этого сервера.
	Таким образом, нам не нужно запоминать число, например, 66.123.52.8, каждый раз, когда вы хотите зайти на какой-либо сайт.
	Вместо этого вы можете просто ввести diontraining.com.
	И поскольку у нас есть DNS-сервер, который преобразует эти имена в IP-адреса и позволяет вам узнать, где мы находимся.

	DNS-сервер будет служить в основном держателем записей для всех внутренних сетевых записей компании и всех ваших имен хостов, или у вас может быть общедоступный DNS-сервер.
	В этом случае мы становимся частью более крупной инфраструктуры разрешения имен в Интернете, так что любой человек в мире может выяснить, где находится diontraining.com.

	+++++++++++++++++++++++++++++++++++
	+ Domain Host Control Server Role +
	+++++++++++++++++++++++++++++++++++

	DHCP-сервер означает Dynamic Host Control Protocol (протокол динамического управления хостом).
	Когда у вас есть сервер или рабочая станция Linux, вам нужно настроить его для участия в сети.
	Это можно сделать статически или динамически.
	
	Если вы собираетесь использовать динамические назначения в своей сети, это означает, что у вас должен быть DHCP-сервер, который будет раздавать эти IP-адреса.
	Когда кто-то подключается к вашей сети, DHCP-сервер будет отвечать за предоставление им IP-адреса, маски подсети, шлюза по умолчанию для вашего маршрутизатора и других значений, таких как местоположение DNS-сервера.
	Выполняя все эти конфигурации, мы можем делать их динамическим образом с помощью DHCP.
	И это действительно упрощает для нас задачу, особенно если у вас много клиентов.
	
	Например, у вас 15 000 рабочих станций и ноутбуков конечных пользователей.
	И вы не хотите настраивать все это статически и назначать все четыре этих фрагмента информации каждому из этих клиентов.
	Поэтому вместо этого мы можем настроить их всех на использование DHCP и направили их на DHCP-сервер нашей сети, который представлял собой машину Linux, раздававшую эту информацию этим клиентам, когда они подключались к сети.

	++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Simple Network Management Protocol Server Role +
	++++++++++++++++++++++++++++++++++++++++++++++++++

	Некоторые из ваших сетевых устройств также могут передавать информацию о своей производительности и рабочих нагрузках в центральную базу данных управления.
	Для этого они используют нечто, известное как SNMP, или Simple Network Management Protocol.
	SNMP позволит нам использовать все эти различные устройства в сети, такие как маршрутизаторы, коммутаторы, серверы и конечные точки, и собирать эту информацию на централизованном сервере.
	Этот централизованный сервер может работать под управлением Linux.
	И если вы настроите его для работы в качестве централизованного сервера базы данных SNMP, он продолжит выполнять эту роль сервера и собирать всю информацию со всех других устройств и клиентов в сети.

	++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Centralized Authentication or LDAP Server Role +
	++++++++++++++++++++++++++++++++++++++++++++++++++

	Следующий сервер, о котором мы поговорим, — это ваш централизованный сервер аутентификации (centralized authentication server).
	И он основан на протоколе, известном как LDAP, что означает Lightweight Directory Access Protocol (легкий протокол доступа к каталогам).
	Этот централизованный сервер аутентификации будет содержать все идентификаторы пользователей на этом централизованном сервере.
	Поэтому, когда кто-то пытается войти в локальную рабочую станцию, например, машину Windows, Mac или Linux, эта система фактически подключается к этому централизованному серверу аутентификации и проверяет, что вы тот, за кого себя выдаете, проверяя ваше имя пользователя и пароль, а затем позволяя вам войти в машину.

	Это делает сеть более безопасной, простой в управлении и гораздо более простой для пользователей, поскольку их одна учетная запись может работать на любой рабочей станции в этой сети, а не только на одном компьютере, который им назначен на рабочем столе.
	Серверы аутентификации используются для хранения всей информации об идентификаторах пользователей внутри этого хранилища каталогов, известного как LDAP.
	Теперь, когда пользователь пытается пройти аутентификацию в системе, его имя пользователя и пароль будут хэшированы, отправлены на сервер аутентификации и проверены по базе данных.
	И если они авторизованы, им будет разрешено войти в эту локальную рабочую станцию.

	+++++++++++++++++++++
	+ Proxe Server Role +
	+++++++++++++++++++++

	Прокси-сервис находится в системе, которая имеет прямое подключение к Интернету, а также имеет другое подключение к внутреннему сетевому подключению.
	Таким образом, он действует как человек в середине соединения.
	И всякий раз, когда кто-то хочет выйти в Интернет, он должен сначала подключиться к прокси-серверу, прокси-сервер принимает этот запрос, передает его в Интернет, получает информацию обратно, а затем передает ее обратно этому конечному пользователю.

	Итак, зачем нам это делать?
	Ну, главная причина, по которой мы хотим это сделать, — это возможность регистрировать любые запросы, которые исходят из нашей сети, и видеть, что делают наши сотрудники внутри нашей организации.
	Например, проверять все машины, коотрые проходят через прокси-сервер, для анализа сайты, на которые они заходят в первую очередь, и если это будет один из тех сайтов, на которые не разрешается заходить, то блокировать это соединение и отправлять соответсвующее сообщение о том, что у вас нет прав на просмотр этого.
	
	Вы также можете использовать его с другой стороны.
	Поскольку данные поступают из сети, вы можете проверить эти данные, чтобы убедиться, что в них нет вирусов или других плохих вещей, прежде чем передавать их на ваши машины внутри.
	Так что это отличная вещь для использования с точки зрения безопасности.

	+++++++++++++++++++++++
	+ Logging Server Role +
	+++++++++++++++++++++++

	Также стоит упоняеть о серверах регистрации (loging servers).
	Один из основных способов создания сервера регистрации — это использование этого протокола регистрации syslog.
	
	Как системному администратору, нам действительно важно понимать, что происходит в нашей сети.
	И мы делаем это, просматривая журналы.
	Теперь, вместо того, чтобы идти на каждый сервер или рабочую станцию ​​и читать их журналы по отдельности, я могу настроить сервер регистрации syslog и заставить все эти устройства отправлять свои данные обратно на мой централизованный сервер регистрации с регулярным интервалом.
	Это можно делать каждую минуту, каждую секунду или с любым другим интервалом, который вам действительно нужен, в зависимости от вашей конфигурации.
	
	Но преимущество ключ здесь в том, что вы можете настроить сервер Linux в качестве этого централизованного сервера регистрации.
	И это одна из таких ролей сервера известная как	-	сервер регистрации syslog.
	Это значительно упрощает для нас архивацию всех этих журналов, особенно если нам нужно доказать, что мы соблюдаем определенные соглашения об уровне обслуживания, или если мы пытаемся устранить неполадки или диагностировать проблему или проверить, что производительность работает так, как должна
	Так что со всей этой централизацией мы можем заставить наши серверы Linux, наши машины Windows, все это пересылать свои журналы на единый сервер журналов syslog, и он будет консолидировать и хранить все эти файлы, где мы затем сможем запрашивать их и просматривать все в одном месте.

	++++++++++++++++++++++++++
	+ Monitoring Server Role +
	++++++++++++++++++++++++++

	В Linux доступно множество различных служб мониторинга.
	Некоторые из этих служб предназначены для определенных приложений.
	Например, есть службы мониторинга, настроенные только для просмотра вашего веб-сервера Apache.
	Есть и другие, настроенные для просмотра всей операционной системы Linux.

	В зависимости от того, что вы делаете, вы можете просмотреть различные службы мониторинга и различные программы мониторинга, чтобы увидеть информацию о различных серверах или ролях сервера.
	Например, если вы хотите просмотреть только Apache, вы можете просмотреть ApacheTop.
	ApacheTop предоставит анализ файла журнала для вашего веб-сервера Apache, а также информацию о различных временах отклика соединения и тому подобном.
	
	Еще одна вещь, которую вы можете использовать	-	Monit.
	Monit — это простая утилита мониторинга для Linux, которая отслеживает использование оборудования, информацию о каталогах и файлах, а затем отслеживает систему внутри известного инструмента с графическим интерфейсом, который позволяет вам собирать информацию о ваших системных ресурсах и о том, как они используются на данном сервере Linux.
	
	Конечно, эти два инструмента не единственные, и существует множество различных инструментов для мониторинга использования вашего процессора и памяти, а также подключений к вашим серверам Linux и с них, в зависимости от вашего варианта использования.

	++++++++++++++++++++++++++++++
	+ Load Balancing Server Role +
	++++++++++++++++++++++++++++++

	Также есть службы балансировки нагрузки, которые вы можете настроить, и это позволит вам распределить входящие запросы на подключение по нескольким серверам.
	Подумайте об этом следующим образом...
	К примеру у вас есть более 500 000 клиентов, и все они могут все подключиться к одному серверу/сервисе одномоментно.
	Это приведет к сбою сервера.
	Поэтому вместо одного сервера/сервиса Вам следует настроить несколько серверов/сервисов.
	И когда они заудет на Ваш сайт, он распределит эту нагрузку по всем серверам/сервисам равномерно.

	Очень часто балансировку нагрузки используют для распределения одного соединения между множеством различных веб-серверов или множеством различных баз данных, чтобы гарантировать лучшую производительность для ваших конечных пользователей.
	Если вы используете веб-сервер, вы не хотите, чтобы один сервер работал и обрабатывал весь ваш трафик, потому что это становится единой точкой отказа.
	И если этот сервер выйдет из строя или будет перегружен, это означает, что никто в мире не сможет получить доступ к вашему контенту.
	Поэтому вместо этого вы хотите использовать балансировку нагрузки и несколько веб-серверов, чтобы уменьшить эту перегрузку и распределить нагрузку между несколькими устройствами.

	++++++++++++++++++++++++++++++
	+ File and Print Server Role +
	++++++++++++++++++++++++++++++

	Файловые и принт-серверы позволят вам делать две основные вещи:
		-	хранить файлы
		-	печатать документы на централизованном принтере.
	
	Централизованная печать очень популярна, особенно в крупных организациях, потому что принтеры очень дорогие.
	А если у каждого на столе есть отдельный принтер, это очень большие капитальные затраты, которые нам нужно иметь, а также много обслуживания.
	Поэтому вместо этого у нас может быть один действительно большой многофункциональный принтер, стоящий на каждом этаже нашего офисного здания, и у нас может быть 50 или сто человек, использующих этот один принтер.
	Это позволяет нам использовать более крупный, более дорогой принтер, но этот более дорогой принтер может обрабатывать гораздо больший объем печати, он не так часто ломается, и его намного проще поддерживать.
	
	Однако для этого вам нужен принт-сервер.
	И поэтому, когда Вы печатаете со своей рабочей станции, данные поступают на принт-сервер, который может работать под управлением Linux.
	А затем они напрямую поступают на принтер, чтобы распечатать их.
	Это помогает снизить ваши расходы на печать, а также обеспечивает более эффективную печать для всех наших пользователей.
	
	Теперь, с другой стороны, нам также нужно иметь возможность хранения файлов.
	И мы делаем это с помощью файловых серверов.
	Есть два основных типа файловых серверов, с которыми вы столкнетесь внутри Linux.

		i)	Samba
			Samba — это совместимая с Windows система обмена файлами, которая работает на SMB или Server Message Block.
			Если у вас есть интегрированная система Linux и Windows для всех ваших серверов и конечных точек, вам нужно будет использовать Samba, чтобы гарантировать, что все ваши устройства могут получить доступ к вашему файловому ресурсу.
			
			Когда дело доходит до Samba, вам нужно подумать о двух ее частях.
			Есть сторона сервера и есть сторона файла.
				-	Если вы используете файловый сервер на сервере Linux и у вас есть клиенты Windows, вам нужно запустить Samba на этом сервере, чтобы иметь возможность общаться с этими клиентами Windows.
				-	Если вы используете систему Linux в качестве настольного компьютера и пытаетесь подключиться к файловому серверу Windows, вам нужно запустить клиент Samba, чтобы вы могли читать в этой среде Windows и иметь доступ к файлам, которые хранятся на этом сервере Windows.

		ii)	NFS
			Если ваша корпоративная сеть состоит только из рабочих станций и серверов Unix и Linux, вы можете вместо этого использовать NFS, что является сетевым общим доступом к файлам.
			NFS — это собственный протокол Unix и Linux, который используется рабочими станциями для доступа к каталогам, которые хранятся на серверах Unix или Linux.
			Опять же, в любом случае, идея здесь заключается в том, чтобы иметь централизованное место для файлов, которые будут находиться на одном сервере или кластере серверов.
			И это значительно упрощает поддержание физической безопасности и резервного копирования этих машин.
			Когда вы настраиваете NFS, вы собираетесь сделать это внутри файла /etsy/exports

	++++++++++++++++++++++++
	+ Database Server Role +
	++++++++++++++++++++++++

	Базы данных могут быть внутренними или внешними, но в этом случае мы поговорим именно о внутренних базах данных.
	Базы данных будут использоваться для хранения больших объемов данных, и это упрощает для вас выполнение запросов к базе данных и получение необходимой информации путем поиска в ней.
	Существует два основных типа баз данных, с которыми вы столкнетесь в своих средах Linux.
		
		-	Базы данных SQL
			Базы данных SQL — это то, что мы называем структурированными базами данных.
			Чтобы взаимодействовать с базой данных SQL и иметь возможность читать из нее, вы будете использовать язык структурированных запросов (Structured Query  Language), который известен как SQL.
			Когда вы используете базу данных SQL, она будет хранить всю свою информацию внутри различных таблиц, которые связаны друг с другом.
			Поэтому мы называем их реляционными базами данных.
			Внутри каждой из этих таблиц данные будут храниться в таблицах и столбцах, и она сможет читать и записывать информацию с помощью SQL в эти базы данных и из них.

		-	Базы данных NoSQL.
			Базы данных NoSQL	-	это нереляционные базы данных.
			В этих базах данных нет централизованного, организованного способа хранения данных.
			Вы можете задаться вопросом, зачем вам база данных NoSQL?
			Что ж, базы данных NoSQL занимают большое место в машинном обучении и ИИ, и они очень, очень популярны в высокоскоростных и высокопроизводительных системах.
			Так что вы столкнетесь с ними, если работаете в очень большой организации, имея дело с большими наборами данных в этом мире больших данных.

	+++++++++++++++++++
	+ VPN Server Role +
	+++++++++++++++++++

	VPN — это виртуальные частные сети.
	Если вы используете VPN-сервер, это позволит удаленным пользователям подключаться к этой внутренней сети компании и получать доступ ко всем вашим внутренним ресурсам, как если бы они физически сидели за своим столом, где было это сетевое местоположение.
	Это действительно полезно, когда вы работаете из дома или в дороге.

	VPN-сервисы действительно важны, потому что они позволяют вам иметь надежный, безопасный туннель из того места, где вы находитесь, в ваш корпоративный офис и в вашу корпоративную среду.

	+++++++++++++++++++++
	+ EMAIL Server Role +
	+++++++++++++++++++++

	В наши дни службы электронной почты являются ключевым компонентом деловых коммуникаций.
	Серверы электронной почты на самом деле отвечают за распространение электронной почты внутри организации или между организациями через Интернет.
	На самом деле электронная почта состоит из двух частей: отправки и получения
	
	Если у вас есть сервер Linux и вы хотите иметь отправляющий сервер, вы должны настроить Sendmail.
	Если вы хотите получать электронную почту, вы должны использовать что-то вроде Postfix.
	Каждый из них будет использовать различные протоколы электронной почты, которые являются общими для всех операционных систем.
	Если вы отправляете электронную почту, вы делаете это с помощью SMTP, который является простым протоколом передачи почты.\
	Если вы получаете электронную почту, вы собираетесь делать это с помощью почтового протокола, или POP3, или вы можете использовать протокол доступа к сообщениям в Интернете, который известен как IMAP.

=====================================================================
* NETWORK *
***********

	++++++++++++++++++++
	+ General Settings +
	++++++++++++++++++++

	Если у вас есть конфигурация, которую вы хотите применять каждый раз при загрузке системы, вы можете вручную отредактировать файлы в каталоге /etc/sysconfig/network-scripts/<file_name>

	++++++++
	+ DHCP +
	++++++++

	Как системный администратор, важно понимать, где вы можете настроить DHCP-клиент в вашей системе Linux.
	Для этого вам нужно будет перейти в файл /etc/dhcp/dhclient.conf
	Этот файл позволяет настраивать параметры DHCP-клиента, включая значения тайм-аута, динамические конфигурации DNS и другие подобные вещи.

	+++++++
	+ DNS +
	+++++++

	Для настройки вашего файла DNS есть статический текстовый файл со всеми параметрами внутри.
	Он называется файлом /etc/hosts.
	Если вы зайдете в свою систему Linux и выполните cat /etc/hosts, вы сможете увидеть, есть ли что-нибудь в вашем файле etc/hosts.

	Если вы хотите иметь какую-то ссылку, которая переопределяет все остальное в вашей системе с точки зрения имен, вы можете поместить ее в файл etc/hosts.
	Например, один из моих детей однажды вечером не делал домашнее задание, и он продолжал сидеть на YouTube.
	Поэтому я зашел в его компьютер, отредактировал его файл etc/hosts и добавил youtube.com, и перенаправил его на IP-адрес веб-сайта его школы.
	Поэтому каждый раз, когда он пытался зайти на YouTube, он просто перенаправлялся на веб-сайт его школы, потому что ваша система всегда сначала проверяет файл etc/hosts прежде чем перейти обратиться в стороннему DNS-серверу, который представляет собой динамическую базу данных, известную как DNS.

	Однако, как ваш клиент узнает, какой DNS-сервер искать?
	Ну, он делает это, просматривая файл /etc/resolv.conf, который хранится локально в каждой системе Linux.
	И он сообщает вашей системе IP-адрес одного или нескольких DNS-серверов.
	Так как DNS весьма важен, то хорошей практикой будет указать по крайней мере два DNS-сервера в вашем файле /etc/resolv.config
	
	Существует еще одно место, где вы можете настроить DNS
	Оно находится в файле /etc/nsswitch.conf и включает в себя несколько различных параметров конфигурации, о которых вам следует знать.
	Например, здесь есть параметр, связанный с разрешением имен, который определяет порядок, в котором методы разрешения имен будут использоваться в вашей системе.
	
	Так что вам следует сначала перейти в etc/hosts, а затем в DNS? Или вам следует сначала перейти в DNS, а затем в /etc/hosts?
	Какой бы из них вы ни выбрали, вам нужно настроить его в вашем файле nsswitch.config.
	Я скажу вам, что в качестве наилучшей практики вам следует сначала перейти в /etc/hosts, а затем перейти к вашему DNS, что является динамическим методом в качестве вашего второго варианта.
	Это то, как ваша система настроена по умолчанию.
	Но если вы хотите изменить это, вы можете сделать это внутри файла /etc/nsswitch.config.
	
	Чтобы настроить различные конфигурации DNS, вы можете вручную редактировать эти файлы, или вы можете пойти по простому пути и использовать инструмент сетевого менеджера.

=====================================================================
* SECURITY *
************

	++++++++++++
	+ Kerberos +
	++++++++++++

	Kerberos — это служба аутентификации, которая основана на чувствительной ко времени системе выдачи билетов.
	Она также часто используется, когда мы используем методы единого входа или SSO для пользователей, чтобы получить доступ к разным сайтам и разным службам.
	
	SSO — это метод, при котором пользователь может ввести свои учетные данные доступа один раз, и они будут переданы на сервер аутентификации, а затем, на основе этого, он получит билет, и затем сможет войти в другие службы по сети или через Интернет.
	Это дает вам список того, что разрешено и что не разрешено на основе этих конкретных учетных данных доступа.

	И хотя Kerberos это служба, используемая в Windows система, в Linux также есть реализация Kerberos

	++++++++++
	+ CHROOT +
	++++++++++

	Если Вы хотите убедиться, что вы просматриваете свои программы и устанавливаете только то, чему доверяете, потому что в некоторых программах может быть установлен бэкдор, который может позволить злоумышленнику получить удаленную оболочку в вашей системе.
	То можете предотвратить это использую утилиту известную как chroot jail.

	Chroot Jail — это способ изолировать процесс и его дочерние элементы от остальной системы.
	Чтобы chroot jail работал, вам нужно убедиться, что он используется только для процессов, которые не нужно запускать как root, потому что пользователь root может легко выйти из jail.
	
	Используя chroot jail, Вы отделяете привилегированный доступ к файловой системе, так что вредоносный или мошеннический процесс не может нанести ущерб за пределами своей среды jail.
	Вся идея здесь в том, что вы можете создать дерево каталогов, в которое вы копируете или связываете все системные файлы, которые вам нужны для запуска этого процесса.
	Например, если использовать команду chroot /home/user /usr/bin/bash, это создаст новый корневой каталог, используя оболочку bash как процесс внутри этой тюрьмы.
	Команду chroot можно запустить, введя chroot, параметры, новый корневой каталог, который вы создаете, в моем случае это был /home/user, а затем команду, которую вы хотите связать с ним.

	++++++++++++++++++++++++
	+ DISK/FILE Encryption +
	++++++++++++++++++++++++

	Полное шифрование диска, известное как FDE (full disk encryption)	-	процесс шифрования всего диска, раздела или тома с помощью аппаратных или программных утилит
	Шифрование файлов шифрует только отдельные файлы и папки в заданной файловой системе с помощью определенной программной утилиты.

	Если вы ищете хорошее независимое от платформы решение для полного шифрования диска, вы можете взглянуть на LUKS (Linux Unified Key Setup)
	Утилита LUKS может шифровать все устройство хранения внутри среды Linux.
	Внутри Linux LUKS будет использовать подсистему dm-crypt, которая была включена в ядро ​​Linux еще в версии 2.6.
	Эта подсистема создаст сопоставление между зашифрованным устройством и именем виртуального устройства, с которым затем может работать программное обеспечение пользовательского пространства.
	LUKS обеспечивает высокую степень совместимости с программным обеспечением, поскольку стандартизирует формат зашифрованных устройств.

	++++++++++++++++++++++++++++++++++++++
	+ Securing User Access Best Pratices +
	++++++++++++++++++++++++++++++++++++++

	1)	Защита конфигурацию загрузчика паролем, чтобы предотвратить несанкционированное вмешательство в параметры загрузки

	2)	Установка пароль в BIOS или UEFI вашей системы, чтобы предотвратить установку или загрузку новой операционной системы несанкционированным персоналом.
	
	3)	Использование команды lsmod для поиска и определение, какие USB-накопители или длругие зависимые модули подключены к вашей системе
		Если вы видите какие-либо модули, которые вам нужно выгрузить, вы можете использовать команду modprobe -r, чтобы выгрузить соответствующие модули из ядра.
		Затем вы можете предотвратить повторную загрузку соответствующих модулей при загрузке, создав файл счерным списком в каталоге /etc/modprobe.d/

	4)	Аудит для ваших пользователей.
		Если Вы хотите убедиться, что все ваши идентификаторы пользователей не будут использоваться совместно, и вместо этого каждый пользователь будет входить в систему, используя свой собственный идентификатор пользователя.
		Это позволит вам проверять все действия, выполняемые пользователем, и таким образом вы сможете поддерживать подотчетность для каждого отдельного пользователя.

	5)	Также, вы можете рассмотреть возможность создания инфраструктуры открытых ключей, чтобы обеспечить использование открытых и закрытых ключей для аутентификации, поскольку это гораздо безопаснее, чем использование имен пользователей и паролей.

	6)	Ограничить доступ к cron, который является планировщиком заданий Linux.
		Сделав это, вы можете помешать неавторизованным пользователям настраивать систему для автоматического запуска вредоносных или нежелательных задач через регулярные интервалы
		Это фактически обойдет их необходимость входить в систему и вводить команду вручную, поэтому вы не хотите этого делать.
		Опять же, вы хотите усложнить злоумышленникам проникновение в вашу систему и совершение плохих действий.

	7)	Отключение использования сочетания клавиш Ctrl+Alt+Del, чтобы пользователи не могли перезагружать систему и нарушать доступность сервиса, если сервер должен постоянно оставаться в рабочем состоянии.

	8)	Служба auditd — это демон аудита, позволяющий использовать записи для аудита того, что записывается в хранилище и какие действия при этом происходят.

	9)	Изменение файла /etc/issue, чтобы добавить баннерное сообщение, которое будет отображать полезную информацию каждый раз, когда пользователь входит в систему.

	10)	Разделение данныз операционной системы и других данных, такие как файлы приложений, на разные разделы, и это даст нам немного больше сегментации и немного больше безопасности.

	11)	Регулярно отслеживать общие уязвимости и уязвимости в базе данных CVE на cve.mitre.org, которая является базой данных MITRE под названием CVE.
		Это веб-сайт, содержит все уязвимости для каждого программного приложения и операционной системы, о которых они знают.
		И поэтому, если вы это сделаете, вы сможете выяснить, есть ли что-то уязвимое в вашей системе, что вам может потребоваться исправить и исправить.

	12)	Укрепить свою систему, отключив или удалив любые неиспользуемые или небезопасные службы.
		Помните, службы — это то, что работает в фоновом режиме вашей системы Linux, и если в ней есть уязвимость, это означает, что злоумышленник может атаковать ее и получить контроль над вашей системой в любое время.
		Существует множество популярных атак на различные службы, такие как FTP, Telnet, Finger, Sendmail и Postfix, и это лишь некоторые из них.

	++++++++++++++++++++++++++++++++++
	+ Identity and Access Management +
	++++++++++++++++++++++++++++++++++

	IAM или управление идентификацией и доступом — это процесс безопасности, который предоставляет механизмы идентификации, аутентификации и авторизации для пользователей, компьютеров и других субъектов для работы с организационными активами, такими как сети, операционные системы и приложения.
	IAM позволяет вам определять атрибуты, которые будут составлять идентификацию субъекта.
	Сюда входят такие вещи, как его цель, его функция, его допуск безопасности и многое другое.
	Теперь в большинстве бизнес-сред IAM считается важнейшей службой для предоставления и управления доступом, а также для укрепления общей безопасности вашей ИТ-инфраструктуры.

	++++++++++++++++
	+ SSH Protocol +
	++++++++++++++++

	Протокол SSH используется для поддержки множества различных методов аутентификации, когда люди пытаются подключиться к серверу SSH.
	Один из самых важных из них известен как PKI или инфраструктура открытых ключей.

	Аутентификация с открытым ключом используется для интерактивных и автоматизированных соединений между различными серверами или между пользователями и серверами.
	Мотивация использования аутентификации с открытым ключом вместо использования простого пароля на самом деле сводится к безопасности.
	Она обеспечивает криптографическую стойкость, которая действительно, действительно мощна по сравнению с обычным паролем.
	
	Совместно с SSH, аутентификация с открытым ключом будет использоваться для значительного повышения безопасности, поскольку она освобождает пользователей от необходимости запоминать эти длинные сложные пароли и делает это более безопасным способом.
	В дополнение к безопасности, аутентификация с открытым ключом также может предложить преимущества удобства использования, поскольку она позволяет пользователям реализовать единый вход на нескольких различных серверах SSH, к которым им нужно будет подключаться.
	Используя аутентификацию с открытым ключом, вы также можете иметь автоматизированный вход без пароля, входя в систему с помощью цифрового сертификата вместо того, чтобы каждый раз запоминать пароль.
	
	Существет много разных файлов, которые необзодимо настроить должным образом при настройке аутентификации на основе ключей внутри SSH.
	Эти файлы будут включены в каталог ~/.shh:

		-	файл id_rsa.
			Он содержит закрытый ключ пользователя.

		-	файл id_rsa.pub
			Он содержит открытый ключ пользователя.

		-	файл authorized_keys
			Он находится на вашем удаленном сервере, в котором будет перечислены все открытые ключи, которые этот сервер примет в качестве средства аутентификации, когда кто-то попытается аутентифицировать своего клиента.

		-	файл known_hosts.
			Он содержит список всех открытых ключей, которые клиент примет в качестве средства для использования этого файла для аутентификации серверов, чтобы попытаться подключиться к нему.

		-	файл конфигурации (config)
			Он будет использоваться для настройки параметров вашего SSH-подключения, например, использования директивы файла идентификации для связывания нескольких ключей с определенными серверами.

	Другой файл, на который стоит обратить внимание	-	/etc/ssh/sshd_config.
	Он используется для настройки сервера SSH в вашей системе Linux.
	Вот некоторые из настроек, которые являются наиболее актуиальными в части настроки безопасности SSH соединения:
		
	-	password authentication параметр
		Он используется для включения или отключения аутентификации на основе пароля.

	-	PubkeyAuthentication параметр
		Ре включает или отключает использование аутентификации на основе открытого ключа.

	-	Hostkey параметр
		Он используется для ссылки на расположение закрытых ключей сервера.

	-	UsePAM параметр
		Он используется для включения или отключения поддержки подключаемых модулей аутентификации, известных как PAM
		
		PAM	-	Pluggable Authentication Modules (подключаемых модулях аутентификации)
		Подключаемые модули аутентификации используются, чтобы помочь приложениям правильно использовать учетные записи пользователей внутри Linux.
		Это отделит стандартные и специализированные задачи аутентификации от самих приложений.
		PAM действительно подключаем в том смысле, что он может иметь разные приложения, запускающие разные тесты и модули, таким образом, что теперь мы можем добавлять разные методы с новыми библиотеками для аутентификации.
		Такие программы, как Login, GDM, SSHD и FTPD, и многие другие, хотят знать, что пользователь является тем, за кого себя выдает, и есть много разных способов сделать это.
		
		Пользователь может предоставить учетные данные имени пользователя и пароля для каждой отдельной службы или он может пройти удаленную аутентификацию с помощью сервера LDAP или Kerberos.
		А как известно LDAP является одним из распространенных способов аутентификации в среде Windiws, а особенно Active Directory.
		Тем не менне Linux может использовать сквозную аутентификацию для этих систем, пересылая свои учетные данные Active Directory через PAM.
		
		Например, вы можете настроить System Security Services Daemon или SSSD для кэширования учетных данных, предоставленных Active Directory или другим внешним механизмом аутентификации.
		И затем SSSD можно использовать с PAM для управления этими удостоверениями.
		Файлы конфигурации PAM будут располагаться внутри каталога /etc/pam.d
		И каждая служба или приложение, поддерживающие PAM, будет иметь свой собственный файл внутри этого каталога.

	-	Port параметр
		Он используется для изменения номера порта для покупки службы SSH на определенном порту.
		По умолчанию это будет порт 22, но вы можете установить его на любой порт по вашему желанию.

	-	SyslogFacility параметр
		Он используется для изменения уровня ведения журнала событий SSH на вашем сервере syslog.

	-	ChrootDirectory параметр
		Он используется в качестве точки отсчета для пути chroot jail для пользователя, предоставляющего доступ.

	-	AllowUsers или AllowGroup параметр
		Это позволяет разрешить доступ для определенных пользователей или групп по SSH.

	-	DenyUsers или DenyGroup параметр
		Он используются для ограничения или блокировки доступа определенных пользователей или групп к вашему серверу по SSH.

	-	PermitRootLogin параметр
		Он используется для включения или отключения возможности входа пользователя root через SSH.
		В качестве хорошей практики безопасности вы обычно хотите отключить возможность входа пользователя root через SSH, потому что это считается опасным.

	В дополнение к разрешению или запрету пользователей и групп, вы также можете запретить подключения к самому серверу SSH, которые исходят от определенных хостов.
	Это делается путем обертывания службы SSH в то, что известно как TCP Wrapper.
	Это даст вам возможность проверять, какие хосты явно разрешены или запрещены, прежде чем разрешить этому хосту подключаться к вашей службе SSH.
	Чтобы иметь возможность настроить это, вы можете указать хост, который вы хотите разрешить, внутри файла /etc/hosts.allow и хост, который вы хотите запретить, внутри файла /etc/hosts.deny

	Now, each of these files are going to include directives